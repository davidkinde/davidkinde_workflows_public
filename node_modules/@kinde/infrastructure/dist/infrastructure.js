var i = /* @__PURE__ */ ((e) => (e[e.accept = 0] = "accept", e[e.deny = 1] = "deny", e))(i || {}), s = /* @__PURE__ */ ((e) => (e.UserTokenGeneration = "user:tokens_generation", e.M2MTokenGeneration = "m2m:tokens_generation", e))(s || {});
const o = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.idToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
}, a = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.accessToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
}, r = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.idToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
};
function c() {
  if (!kinde.idToken)
    throw new Error("IdToken binding not available");
  const e = kinde.idToken.getCustomClaims();
  return new Proxy(e, o);
}
function m() {
  if (!kinde.accessToken)
    throw new Error("accessToken binding not available");
  const e = kinde.accessToken.getCustomClaims();
  return new Proxy(e, a);
}
function k() {
  if (!kinde.m2mToken)
    throw new Error("m2mToken binding not available");
  const e = kinde.m2mToken.getCustomClaims();
  return new Proxy(e, r);
}
function d(e) {
  return kinde.env.get(e);
}
function l(e) {
  kinde.auth.denyAccess(e);
}
export {
  i as WorkflowResult,
  s as WorkflowTrigger,
  m as accessTokenCustomClaims,
  l as denyAccess,
  d as getEnvironmentVariable,
  c as idTokenCustomClaims,
  k as m2mTokenClaims
};
