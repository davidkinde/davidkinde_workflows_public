var o = /* @__PURE__ */ ((e) => (e[e.accept = 0] = "accept", e[e.deny = 1] = "deny", e))(o || {}), i = /* @__PURE__ */ ((e) => (e.UserTokenGeneration = "user:tokens_generation", e.M2MTokenGeneration = "m2m:tokens_generation", e))(i || {});
const a = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.idToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
}, s = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.accessToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
}, r = {
  get(e, n, t) {
    return Reflect.get(e, n.toString(), t);
  },
  set(e, n, t) {
    return kinde.idToken.setCustomClaim(n, t), Reflect.set(e, n, t);
  }
};
function l() {
  if (!kinde.idToken)
    throw new Error("IdToken binding not available, please add to workflow settings to enable");
  const e = kinde.idToken.getCustomClaims();
  return new Proxy(e, a);
}
function c() {
  if (!kinde.accessToken)
    throw new Error("accessToken binding not available, please add to workflow settings to enable");
  const e = kinde.accessToken.getCustomClaims();
  return new Proxy(e, s);
}
function d() {
  if (!kinde.m2mToken)
    throw new Error("m2mToken binding not available, please add to workflow settings to enable");
  const e = kinde.m2mToken.getCustomClaims();
  return new Proxy(e, r);
}
function m(e) {
  if (!kinde.env)
    throw new Error("env binding not available, please add to workflow settings to enable");
  const n = kinde.env.get(e);
  return {
    value: n.value,
    isSecret: n.isSecret
  };
}
function k(e) {
  if (!kinde.auth)
    throw new Error("auth binding not available");
  kinde.auth.denyAccess(e);
}
export {
  o as WorkflowResult,
  i as WorkflowTrigger,
  c as accessTokenCustomClaims,
  k as denyAccess,
  m as getEnvironmentVariable,
  l as idTokenCustomClaims,
  d as m2mTokenClaims
};
